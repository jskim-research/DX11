Texture2D shaderTexture : register(t0);
Texture2DArray gltfTextures : register(t1);
SamplerState SampleType : register(s0);

cbuffer LightBuffer
{
	float4 diffuseColor;
	float3 lightDirection;
	// 16 의 배수 제약 만족시키기 위함
	float padding;
};

cbuffer CameraBuffer
{
	float3 cameraLocation;
	float cameraPadding;
};

struct PixelInputType
{
	float4 position : SV_POSITION;
	float3 normal : NORMAL;
	float4 color : COLOR;
	float2 tex : TEXCOORD0;
	nointerpolation uint imageIndex : TEXCOORD1;
};

float SmoothStep(float x)
{
	return 3 * pow(x, 2) - 2 * pow(x, 3);
}

float CustomStep(float y, float x, float defaultValue)
{
	if (y < x) return 1;
	else return defaultValue;
}

float4 CartoonPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	// diffuse 계산용
	float3 lightDir;
	float lightIntensity;
	float4 color;

	// 카툰 렌더링 명암 계산용
	float4 gradientMap;
	float4 startColor = float4(0, 0, 0, 1);
	float4 endColor = float4(1, 1, 1, 1);

	// specular 계산용
	float3 viewDirection;
	float3 reflectionLight;
	float3 halfVector;
	// roughness ~ sqrt(2 / shininess)
	// shininess = 50 은 roughness 0.2 정도임
	float specularShininess = 50;
	float specular;
	float4 specularColor = float4(1, 1, 1, 1);

	textureColor = gltfTextures.Sample(SampleType, float3(input.tex, input.imageIndex));
	lightDir = -lightDirection;
	lightIntensity = saturate(dot(lightDir, input.normal));

	gradientMap = step(0.1, lightIntensity);
	gradientMap = (1 - gradientMap) * startColor + gradientMap * endColor;

	// Phong Specular BRDF
	viewDirection = normalize(cameraLocation - input.position.xyz);
	reflectionLight = normalize(2 * dot(lightDir, input.normal) * input.normal - lightDir);
	// dot 값 saturate 해야 음수값이 0으로 처리됨
	// 음수값을 0으로 치환해버리므로 특정 부분에서 부자연스럽게 변화
	// specular = pow(saturate(dot(viewDirection, reflectionLight)), specularShininess);

	// Blinn-Phong Specular BRDF
	halfVector = normalize(lightDir + viewDirection);
	// 기존엔 음수값인 부분을 정상적으로 specular 에 편입
	// 자연스러운 변화
	specular = pow(saturate(dot(halfVector, input.normal)), specularShininess);

	color = textureColor * gradientMap;
	color = color + specularColor * specular;
	return color;
}