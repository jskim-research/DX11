#define NUM_LIGHTS 4

Texture2D shaderTexture : register(t0);
Texture2DArray gltfTextures : register(t1);
SamplerState SampleType : register(s0);

cbuffer LightBuffer : register(b0)
{
	float4 diffuseColor;
	float3 lightDirection;
	// 16 의 배수 제약 만족시키기 위함
	float padding;
};

cbuffer CameraBuffer : register(b1)
{
	float3 cameraLocation;
	float cameraPadding;
};

struct PointLightBufferType
{
	float4 diffuseColor;
	float3 position;
	float padding1;
	float3 attenuationFactors;
	float padding2;
};

cbuffer PointLightBuffer : register(b2)
{
	PointLightBufferType pointLights[NUM_LIGHTS];
};

cbuffer UtilityVariableBufferType : register(b3)
{
	bool isOutline;
	float3 util_padding1;
};

struct PixelInputType
{
	float4 position : SV_POSITION;
	float3 worldPosition : POSITION;
	float3 normal : NORMAL;
	float4 color : COLOR;
	float2 tex : TEXCOORD0;
	float3 screenNormal : NORMAL1;
	nointerpolation uint imageIndex : TEXCOORD1;
};

float SmoothStep(float x)
{
	return 3 * pow(x, 2) - 2 * pow(x, 3);
}

float CustomStep(float y, float x, float defaultValue)
{
	if (y < x) return 1;
	else return defaultValue;
}

float4 CalculateDiffuse(float3 _lightDirection, float3 _normal)
{
	float lightIntensity = saturate(dot(-_lightDirection, _normal));
	return lightIntensity;
}

float4 CalculatePointLightDiffuse(float3 _lightPosition, float3 _inputPosition, float3 _inputNormal, float3 _attenuationFactors)
{
	float3 lightDirection = _lightPosition - _inputPosition;
	float lightIntensity = saturate(dot(normalize(lightDirection), _inputNormal));
	float dist = length(lightDirection);

	return lightIntensity / dot(_attenuationFactors, float3(1, dist, pow(dist,2)));	
}

float4 CalculateCartoonDiffuse(float3 _lightDirection, float3 _normal)
{
	// 카툰 렌더링 명암 계산용
	float4 gradientMap;
	float4 startColor = float4(0, 0, 0, 1);
	float4 endColor = float4(1, 1, 1, 1);
	float lightIntensity = saturate(dot(-_lightDirection, _normal));

	gradientMap = step(0.1, lightIntensity);
	gradientMap = (1 - gradientMap) * startColor + gradientMap * endColor;

	return gradientMap;
}

float CalculatePhongSpecular(float3 _cameraLocation, PixelInputType _input, float3 _lightDirection, float _specularShininess)
{
	float3 viewDirection;
	float3 reflectionLight;
	// roughness ~ sqrt(2 / shininess)
	// shininess = 50 은 roughness 0.2 정도임
	float specular;
	float4 specularColor = float4(1, 1, 1, 1);
	float lightIntensity = saturate(dot(-_lightDirection, _input.normal));

	viewDirection = normalize(_cameraLocation - _input.position.xyz);
	reflectionLight = normalize(2 * dot(-_lightDirection, _input.normal) * _input.normal + _lightDirection);

	if (lightIntensity <= 0) 
		// 애초에 반사가 안되는 상황
		specular = 0;
	else
		// dot 값 saturate 해야 음수값이 0으로 처리됨
		// 음수값을 0으로 치환해버리므로 특정 부분에서 부자연스럽게 변화
		specular = pow(max(dot(viewDirection, reflectionLight), 0), _specularShininess);

	return specular;
}

float CalculateBlinnPhongSpecular(float3 _cameraLocation, PixelInputType _input, float3 _lightDirection, float _specularShininess)
{
	float3 viewDirection = normalize(_cameraLocation - _input.position.xyz);
	float3 reflectionLight = normalize(2 * dot(-_lightDirection, _input.normal) * _input.normal + _lightDirection);
	float3 halfVector = normalize(-_lightDirection + viewDirection);
	float specular;
	float lightIntensity = saturate(dot(-_lightDirection, _input.normal));

	if (lightIntensity <= 0)
		specular = 0;
	else
		// Phong specular 와 달리 음수가 되는 경우 없이 전부 반영
		specular = pow(saturate(dot(halfVector, _input.normal)), _specularShininess);
	return specular; 
}

float CalculatePointLightBlinnPhongSpecular(float3 _cameraLocation, PixelInputType _input, float3 _lightPosition, float3 _attenuationFactors, float _specularShininess)
{
	float3 _lightDirection = _lightPosition - _input.worldPosition.xyz;
	float dist = length(_lightDirection);
	_lightDirection = normalize(_lightDirection);
	float3 viewDirection = normalize(_cameraLocation - _input.worldPosition.xyz);
	float3 reflectionLight = normalize(2 * dot(-_lightDirection, _input.normal) * _input.normal + _lightDirection);
	float3 halfVector = normalize(-_lightDirection + viewDirection);
	float specular;
	float lightIntensity = saturate(dot(-_lightDirection, _input.normal));

	if (lightIntensity <= 0)
		specular = 0;
	else
		// Phong specular 와 달리 음수가 되는 경우 없이 전부 반영
		specular = pow(saturate(dot(halfVector, _input.normal)), _specularShininess);
	specular /= (dot(_attenuationFactors, float3(1, dist, pow(dist,2))));
	return specular; 
}

float4 CartoonPixelShader(PixelInputType input) : SV_TARGET
{	
	float4 color;
	float4 textureColor;

	float4 ambient = float4(0.1, 0.1, 0.1, 1);
	float4 diffuse;
	float specular;
	float4 specularColor = float4(1, 1, 1, 1);
	
	if (isOutline && dot(normalize(input.worldPosition - cameraLocation), input.normal) >= 0)
		return float4(1, 0, 0, 0);
	else if (isOutline)
		discard;
	

	textureColor = gltfTextures.Sample(SampleType, float3(input.tex, input.imageIndex));

	diffuse = 0;
	specular = 0;
	
	// directional light
	
	diffuse += diffuseColor * CalculateDiffuse(lightDirection, input.normal);
	// specular += CalculatePhongSpecular(cameraLocation, input, lightDirection, 50);	
	specular += CalculateBlinnPhongSpecular(cameraLocation, input, lightDirection, 50);
	diffuse = step(0.1, diffuse);
	
	// point lights
	// 여기엔 step(0.1, diffuse) 적용 시 약간 어색한 부분이 있어서
	// directional light 에만 적용해둔 상태
	for (int i=0; i<NUM_LIGHTS; i++)
	{
		diffuse += pointLights[i].diffuseColor * CalculatePointLightDiffuse(pointLights[i].position, input.worldPosition, input.normal, pointLights[i].attenuationFactors);
		// pointLights[i].specularColor 추가해야함
		// specular += CalculatePointLightBlinnPhongSpecular(cameraLocation, input, pointLights[i].position, pointLights[i].attenuationFactors, 50);
	}

	color = textureColor * (ambient + diffuse); // + specularColor * specular;
	
	return color;
}